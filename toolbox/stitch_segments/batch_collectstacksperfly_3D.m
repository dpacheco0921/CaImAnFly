function batch_collectstacksperfly_3D(FolderName, FileName, iparams)
% batch_collectstacksperfly_3D: Second part of preprocessing for data
% that does not undergo compiling.
%   1) reads metadata generated by batch_SpaTemp_ResFilt_3D 
%   2) saves variables in a ROIseg-compatible way
%
% Usage:
%   batch_SpaTemp_ResFilt_3D(FolderName, FileName, iparams)
%
% Args:
%   FolderName: Folder name to load
%   FileName: File name to load
%   iparams: parameters to update
%       (cDir: current directory)
%       (debug: debug gate)
%       (fo2reject: folders to reject)
%       (fi2reject: files to reject)
%       (fisuffix: suffix of files to load)
%       (oDir: temporary folder to copy data to)
%           (default, [])
%       (idp_run_flag: flag to run each selected file independently)
%           (default, 0)
%       (green_field2save: flag to save Data variable as [Y Yr], Yr is Y in 2D)
%           (default, [1 1])
%       (red_field2save: flag to save Data variable as [Y Yr], Yr is Y in 2D)
%           (default, [0 1])
%       (patch_z_size: dimension of patches to split whole matrix into)
%           (default, [10])
%       (patch_overlap: overlap across patches)
%           (default, [0 0 0])
%       (neighcor_flag: compute correlation of neighboring pixels acrosstime)
%           (default, 0)
%       %%%%%%%%%%%% shift fluorescence distribution %%%%%%%%%%%%
%       (bkgate: flag for background substraction)
%           (default, 0)
%       (blowcap: fluorescence below which it is zerored)
%           (default, 0)
%       (fshift: shift distribution of F to the positive side)
%           (default, 6)
%       %%%%%%%%%%%% parpool & server related %%%%%%%%%%%%
%       (serId: server id)
%           (default, 'int')
%       (corenum: number of cores)
%           (default, 4)

cspf_3d = [];
cspf_3d.cDir = pwd;
cspf_3d.fo2reject = {'.', '..', 'preprocessed', 'BData'};
cspf_3d.fi2reject = {'Zstack'};
cspf_3d.fisuffix = '_rawdata';
cspf_3d.oDir = [];
cspf_3d.idp_run_flag = 0;
cspf_3d.green_field2save = [1 1];
cspf_3d.red_field2save = [0 1];
cspf_3d.patch_z_size = 10;
cspf_3d.patch_overlap = [0 0 0];
cspf_3d.neighcor_flag = 0;
cspf_3d.bkgate = 0;
cspf_3d.blowcap = 0;
cspf_3d.fshift = 6;
cspf_3d.serId = 'int';
cspf_3d.corenum = 4;

% update variables
if ~exist('FolderName', 'var'); FolderName = []; end
if ~exist('FileName', 'var'); FileName = []; end
if ~exist('iparams', 'var'); iparams = []; end
cspf_3d = loparam_updater(cspf_3d, iparams);

% start pararell pool if not ready yet
ppobj = setup_parpool(cspf_3d.serId, cspf_3d.corenum);

if ~isempty(cspf_3d.oDir)
    
    if ~exist(cspf_3d.oDir, 'dir')
        mkdir(cspf_3d.oDir);
    end    

else
    
    cspf_3d.oDir = [];
    
end
fprintf(['Saving output files at : ', ...
	strrep(cspf_3d.oDir, filesep, ' '), '\n'])

% find folders
f2run = dir;
f2run = str2match(FolderName, f2run);
f2run = str2rm(cspf_3d.fo2reject, f2run);
f2run = {f2run.name};
fprintf(['Running n-folders : ', num2str(numel(f2run)), '\n'])

for i = 1:numel(f2run)
    
    fprintf(['Running folder : ', f2run{i}, '\n']); 
    cd(f2run{i});
    runperfolder(FileName, cspf_3d);
    cd(cspf_3d.cDir);
    fprintf('\n')
    
end

delete_parpool(ppobj);

fprintf('... Done\n')

end

function runperfolder(fname, cspf_3d)
% runperfolder: run all files per folder
%
% Usage:
%   runperfolder(fname)
%
% Args:
%   fname: file name pattern
%   cspfb_3d: parameter variable

% determine if fname narrows down to just one file
[f2plot, ~, rep2plot] = rdir_namesplit(...
    fname, '.mat', cspf_3d.fisuffix, ...
    cspf_3d.fi2reject, [], 1);
fprintf('Reformatting stacks from');

if cspf_3d.idp_run_flag == 1
    
    for i = 1:numel(f2plot)
        % run single file
        f2plot{i} = [f2plot{i}, '_', num2str(rep2plot(i))];
    end
    fprintf(' each seg independently ') 
    
else
    
    if numel(f2plot) == 1 && numel(rep2plot) == 1
        % run single file
        f2plot{1} = [f2plot{1}, '_', num2str(rep2plot)];
        fprintf(' one fly_seg ')
    else
        % Run all flies per folder
        f2plot = unique(f2plot);
    end
    
end

fprintf([num2str(numel(f2plot)), ' flies\n'])

for file_i = 1:numel(f2plot)
    
    % Compiling all stacks per fly
    [filename, ~, repnum] = ...
        rdir_namesplit(f2plot{file_i}, ...
        '.mat', cspf_3d.fisuffix, cspf_3d.fi2reject, [], 1);
    
    % run per fly
    for rep_i = 1:numel(repnum)
        
        if numel(filename) == 1
            
            fprintf(['Reformatting fly: ', ...
                filename{1}, '_', num2str(repnum(rep_i)),'\n'])
            fcompiler([filename{1}, '_', num2str(repnum(rep_i))], cspf_3d);
            
        else
            fprintf('error')
        end
        
    end
    
end

end

function fcompiler(fname, cspf_3d)
% fcompiler: for each filename compile all sub-stacks in the right order
%
% Usage:
%   fcompiler(fname)
%
% Args:
%   fname: file name
%   cspf_3d: parameter variable

% load previously generated wdat
load([fname, '_metadata.mat'], 'wDat');
wDat.cDir = pwd;

% add local folder
if isfield(wDat, 'min_f')
    wDat = rmfield(wDat, 'min_f');
end

% rerun already used metadata
if isfield(wDat, 'cspf')
    
    % it has already being used to compile Data
    fprintf('Reseting metadata to be reused\n')
    
    if ~isempty(strfind(wDat.bSide, 'R'))
        
        % reset original order in frame width
        wDat.mask = flip(wDat.mask, 2);
        wDat.bMask = flip(wDat.bMask, 2);
        wDat.RedChaMean = flip(wDat.RedChaMean, 2);
        wDat.GreenChaMean = flip(wDat.GreenChaMean, 2);
        
    end
    
end

% correct each channel separately
vList = whos('-file', [fname, '_rawdata']);

if ~contains([vList.name], 'Y')
    
    % saves Y and Yr
    wDat = savedata_per_cha(fname, 'green', wDat, ...
        cspf_3d.green_field2save, ...
        cspf_3d.bkgate, cspf_3d.fshift, ...
        cspf_3d.blowcap, cspf_3d.patch_z_size, ...
        cspf_3d.patch_overlap);
    
    % only saves Yr
    try
        wDat = savedata_per_cha(fname, 'red', wDat, ...
            cspf_3d.red_field2save, ...
            cspf_3d.bkgate, cspf_3d.fshift, ...
            cspf_3d.blowcap, cspf_3d.patch_z_size, ...
            cspf_3d.patch_overlap);
    end
    
end

% save metadata
dataObj = matfile([fname, '_rawdata.mat'], 'Writable', true);

if ~isempty(strfind(wDat.bSide, 'R'))
    
    % Correct for side of the brain imaged
    wDat.mask = flip(wDat.mask, 2);
    wDat.bMask = flip(wDat.bMask, 2);
    wDat.RedChaMean = flip(wDat.RedChaMean, 2);
    wDat.GreenChaMean = flip(wDat.GreenChaMean, 2);
    
end

% perform 3D neighcorr
if cspf_3d.neighcor_flag
    wDat.lc3D = neighcorr_3D(dataObj);
end

% compile field
wDat.cspf = 1; 
save([fname, '_metadata.mat'], 'wDat', '-append');

if ~isempty(cspf_3d.oDir)
    
    tinit_i = tic;
    copyfile([fname, '_metadata.mat'], ...
        [cspf_3d.oDir, filesep, fname, '_metadata.mat']);
    fprintf([num2str(toc(tinit_i)), ' seconds\n'])

    tinit_i = tic;
    copyfile([fname, '_rawdata.mat'], ...
        [cspf_3d.oDir, filesep, fname, '_rawdata.mat']);
    fprintf([num2str(toc(tinit_i)), ' seconds\n'])
    
    try
        tinit_i = tic;
        copyfile([fname, '_refdata.mat'], ...
            [cspf_3d.oDir, filesep, fname, '_refdata.mat']);
        fprintf([num2str(toc(tinit_i)), ' seconds\n'])
    end
    
end

end

function wDat = savedata_per_cha(fname, cha2use, wDat, ...
    format2save, bkgate_, fshift_, blowcap_, patch_z_size, ...
    patch_overlap)
% savedata_per_cha: compile variable Data and transform it to Y and Yr for
% each channel selected, it also generates new wDat fields: GreenTrend, RedTrend
%
% Usage:
%   savedata_per_cha(fname, cha2use, wDat, format2save)
%
% Args:
%   fname: file to load
%   cha2use: channel to use (green = *_rawdata or red = *_refdata)
%   wDat: metadata structure
%   format2save: flag to save Y and/or Yr
%   bkgate: flag for background substraction
%   	(default, 0)
%   fshift: shift distribution of F to the positive side
%   	(default, 6)
%   blowcap: fluorescence below which it is zerored
%   	(default, 0)
%   patch_z_size: dimension of patches to split whole matrix into
%       (default, [10])
%   patch_overlap: overlap across patches
%       (default, [0 0 0])

% generate 
patches_ = construct_patches(wDat.vSize, ...
    [wDat.vSize([1 2]), patch_z_size], ...
    patch_overlap);

tinit = tic;

% Load files
if contains(cha2use, 'green')
    
    % green channel
    dataObj_in = matfile([fname, '_rawdata.mat'], 'Writable', true);
    dataObj_out = matfile([fname, '_rawdata_temp.mat'], 'Writable', true);
    
elseif contains(cha2use, 'red')
    
    % red channel
    dataObj_in = matfile([fname, '_refdata.mat'], 'Writable', true);
    dataObj_out = matfile([fname, '_refdata_temp.mat'], 'Writable', true);
    
end

% Compile stacks
z_i = 0;
p_i = 0;
minval = zeros(numel(patches_), 1);

if strcmp(wDat.vOrient, 'invert')
    patches_i = sort(1:numel(patches_), 'descend');
else
    patches_i = sort(1:numel(patches_), 'ascend');
end

for i = 1:numel(patches_)
    
    % load, reshape, prune, flip on Z and X axis patches of data
    tinit_i = tic;
    if contains(cha2use, 'green')
        [Y, wDat.GreenTrend(i, :), minval(i, 1)] = ...
            load_reshape_data_patch(dataObj_in, ...
            patches_{patches_i(i)}, wDat, bkgate_, ...
            fshift_, blowcap_, cha2use);
    elseif contains(cha2use, 'red')
        [Y, wDat.RedTrend(i, :), minval(i, 1)] = ...
            load_reshape_data_patch(dataObj_in, ...
            patches_{patches_i(i)}, wDat, bkgate_, ...
            fshift_, blowcap_, cha2use);
    end
    
    % get relative depth
    planes = 1:size(Y, 3);
    planes = planes + z_i;
    z_i = planes(end);
    
    % saving data using relative indexes
    if format2save(1)
        dataObj_out.Y(1:wDat.fSize(1), 1:wDat.fSize(2), ...
            planes, 1:wDat.Tn) = Y;
    end
    Zn = size(Y, 3);

    % indexes are sequential from plane to plane
    pixelindex = 1:prod([wDat.fSize, Zn]);
    pixelindex = pixelindex + p_i;
    p_i = pixelindex(end);
    if format2save(2)
        dataObj_out.Yr(pixelindex, 1:wDat.Tn) = ...
            reshape(Y, [prod([wDat.fSize, Zn]), wDat.Tn]);
    end
    fprintf([num2str(toc(tinit_i)), ' seconds\n'])
    
end
fprintf('\n')

dataObj_out.nY = min(minval);
dataObj_out.sizY = [wDat.vSize, wDat.Tn];
clear Y

% delete original:
if contains(cha2use, 'green')
    delete([fname, '_rawdata.mat'])
    movefile([fname, '_rawdata_temp.mat'], ...
        [fname, '_rawdata.mat']);
elseif contains(cha2use, 'red')
    delete([fname, '_refdata.mat'])
    movefile([fname, '_refdata_temp.mat'], ...
        [fname, '_refdata.mat']);
end
% rename new:

fprintf([num2str(toc(tinit)), ' seconds\n'])

end

function [Y, trend_over_time, minval] = ...
    load_reshape_data_patch(dataObj, ...
    patches_, wDat, bkgate_, fshift_, ...
    blowcap_, cha2use)
% load_reshape_data_patch: compile patches of 'dataObj.Data' matrix using 'patches_'
%   it formats Y (flip in X and Z axis), and prune nan pixels, and
%   generates trend_over_time (mean trend over time)
%
% Usage:
%   [Y, trend_over_time, minval] = ...
%       load_reshape_data_patch(dataObj, ...
%       patches_, wDat, bkgate_, fshift_, ...
%       blowcap_, cha2use)
%
% Args:
%   dataObj: mat file object (looks for variable Data)
%   patches_: edges of 'dataObj.Data' to use
%   wDat: metadata structure
%   bkgate: flag for background substraction
%   	(default, 0)
%   fshift: shift distribution of F to the positive side
%   	(default, 6)
%   blowcap: fluorescence below which it is zerored
%   	(default, 0)
%   cha2use: channel to use (green = *_rawdata or red = *_refdata)

z_idx = patches_(5):patches_(6);

% load patch
Y = dataObj.Data(patches_(1):patches_(2), ...
    patches_(3):patches_(4), ...
    z_idx, :);

% load brain mask (whole image)
brainmask = wDat.bMask(patches_(1):patches_(2), ...
    patches_(3):patches_(4), :);

% Correct for inverse z order
%  wDat.plane2keep & brainmask (wDat.bMask)
if strcmp(wDat.vOrient, 'invert')
    plane2keep = flip(wDat.plane2keep);
    brainmask = flip(brainmask, 3);
else
    plane2keep = wDat.plane2keep;
end
brainmask = brainmask(:, :, z_idx);

% remove whole nan-planes
Y = Y(:, :, plane2keep(z_idx), :);
brainmask = brainmask(:, :, plane2keep(z_idx));

% get trend per patch
trend_over_time = [];
trend_over_time(1, :) = stacktrend(Y, brainmask);

% Correct for inverse z order (Y)
if strcmp(wDat.vOrient, 'invert')
    Y = flip(Y, 3);
end

% Prune Data
%   (wDat.mask generated by batch_SpaTemp_ResFilt_3D)
Y = pruneIm(Y, wDat.mask);

% correct for side of the brain imaged
%   (wDat.bMask generated by batch_brainmaskgen)
if ~isempty(strfind(wDat.bSide, 'R'))
    Y = flip(Y, 2);
end

% background substract F
if bkgate_
    if cha2use == 1
        Y = Y - wDat.bs(end); 
    else
        Y = Y - wDat.bs(1);
    end
end

Y = Y + fshift_;
Y(Y < blowcap_) = blowcap_;

minval = min(Y(:));

end

function fmed = stacktrend(Y, mask)
% stacktrend: get median trend per stack Y for just neural tissue (using mask)
%
% Usage:
%   stacktrend(Y, mask)
%
% Args:
%   Y: 3D stack
%   mask: mask that defines pixels to use

dDim = size(Y);
mask = mask(:);
Y = reshape(Y, [prod(dDim(1:3)), dDim(4)]);
Y = Y(mask ~= 0, :);
fmed = median(Y, 1);

end
