function batch_collectstacksperfly_3D(FolderName, FileName, iparams)
% batch_collectstacksperfly_3D: Second part of preprocessing for data
% that does not undergo compiling.
%   1) reads metadata generated by batch_SpaTemp_ResFilt_3D 
%   2) saves variables in a ROIseg-compatible way
%
% Usage:
%   batch_SpaTemp_ResFilt_3D(FolderName, FileName, iparams)
%
% Args:
%   FolderName: Folder name to load
%   FileName: File name to load
%   iparams: parameters to update
%       (cDir: current directory)
%       (debug: debug gate)
%       (fo2reject: folders to reject)
%       (fi2reject: files to reject)
%       (fisuffix: suffix of files to load)
%       (oDir: temporary folder to copy data to)
%           (default, [])
%       %%%%%%%%%%%% shift fluorescence distribution %%%%%%%%%%%%
%       (bkgate: flag for background substraction)
%           (default, 0)
%       (blowcap: fluorescence below which it is zerored)
%           (default, 0)
%       (fshift: shift distribution of F to the positive side)
%           (default, 6)
%       %%%%%%%%%%%% parpool & server related %%%%%%%%%%%%
%       (serId: server id)
%           (default, 'int')
%       (corenum: number of cores)
%           (default, 4)

cspf_3d = [];
cspf_3d.cDir = pwd;
cspf_3d.fo2reject = {'.', '..', 'preprocessed', 'BData'};
cspf_3d.fi2reject = {'Zstack'};
cspf_3d.fisuffix = '_rawdata';
cspf_3d.oDir = [];
cspf_3d.bkgate = 0;
cspf_3d.blowcap = 0;
cspf_3d.fshift = 6;
cspf_3d.serId = 'int';
cspf_3d.corenum = 4;

% update variables
if ~exist('FolderName', 'var'); FolderName = []; end
if ~exist('FileName', 'var'); FileName = []; end
if ~exist('iparams', 'var'); iparams = []; end
cspf_3d = loparam_updater(cspf_3d, iparams);

% start pararell pool if not ready yet
ppobj = setup_parpool(cspf_3d.serId, cspf_3d.corenum);

if ~isempty(cspf_3d.oDir)
    
    if ~exist(cspf_3d.oDir, 'dir')
        mkdir(cspf_3d.oDir);
    end    
    fprintf(['Copying output files at : ', ...
        strrep(cspf_3d.oDir, filesep, ' '), '\n'])

else
    
    cspf_3d.oDir = pwd;
    fprintf(['Saving output files at : ', ...
        strrep(cspf_3d.oDir, filesep, ' '), '\n'])
    
end

% find folders
f2run = dir;
f2run = str2match(FolderName, f2run);
f2run = str2rm(cspf_3d.fo2reject, f2run);
f2run = {f2run.name};
fprintf(['Running n-folders : ', num2str(numel(f2run)), '\n'])

for i = 1:numel(f2run)
    
    fprintf(['Running folder : ', f2run{i}, '\n']); 
    cd(f2run{i});
    runperfolder(FileName, cspf_3d);
    cd(cspf_3d.cDir);
    fprintf('\n')
    
end

delete_parpool(ppobj);

fprintf('... Done\n')

end

function runperfolder(fname, cspf_3d)
% runperfolder: run all files per folder
%
% Usage:
%   runperfolder(fname)
%
% Args:
%   fname: file name pattern
%   cspfb_3d: parameter variable

% determine if fname narrows down to just one file
[f2plot, ~, rep2plot] = rdir_namesplit(...
    fname, '.mat', cspf_3d.fisuffix, ...
    cspf_3d.fi2reject, [], 1);
fprintf('Reformatting stacks from');

if numel(f2plot) == 1 && numel(rep2plot) == 1
    % run single file
    f2plot{1} = [f2plot{1}, '_', num2str(rep2plot)];
    fprintf(' one fly_seg ')    
else
    % Run all files per folder
    f2plot = unique(f2plot);
end

fprintf([num2str(numel(f2plot)), ' flies\n'])

for file_i = 1:numel(f2plot)
    
    % Compiling all stacks per fly
    [filename, ~, repnum] = ...
        rdir_namesplit(f2plot{file_i}, ...
        '.mat', cspf_3d.fisuffix, cspf_3d.fi2reject, [], 1);
    
    % run per fly
    for rep_i = 1:numel(repnum)
        
        if numel(filename) == 1
            
            fprintf(['Reformatting fly: ', ...
                filename{1}, '_', num2str(repnum(rep_i)),'\n'])
            fcompiler([filename{1}, '_', num2str(repnum(rep_i))], cspf_3d);
            
        else
            fprintf('error')
        end
        
    end
    
end

end

function fcompiler(fname, cspf_3d)
% fcompiler: for each filename compile all sub-stacks in the right order
%
% Usage:
%   fcompiler(fname)
%
% Args:
%   fname: file name
%   cspf_3d: parameter variable

if exist('flip', 'builtin')
    str2use = 'flip';
else
    str2use = 'flipdim';
end

% load previously generated wdat
load([fname, '_metadata.mat'], 'wDat');
wDat.cDir = pwd;

% add local folder
if isfield(wDat, 'min_f')
    wDat = rmfield(wDat, 'min_f');
end

% rerun already used metadata
if isfield(wDat, 'cspf')
    
    % it has already being used to compile Data
    fprintf('Reseting metadata to be reused\n')
    
    if ~isempty(strfind(wDat.bSide, 'R'))
        
        % reset original order in frame width
        eval(['wDat.mask = ', str2use, '(wDat.mask, 2);']);
        eval(['wDat.bMask = ', str2use, '(wDat.bMask, 2);']);
        eval(['wDat.RedChaMean = ', str2use, '(wDat.RedChaMean, 2);']);
        eval(['wDat.GreenChaMean = ', str2use, '(wDat.GreenChaMean, 2);']);
        
    end
    
end

% correct each channel separately
vList = whos('-file', [fname, '_rawdata']);

if ~contains([vList.name], 'Y')
    
    % saves Y and Yr
    wDat = savedata_per_cha(fname, 1, wDat, [1 1], ...
        cspf_3d.bkgate, cspf_3d.fshift, cspf_3d.blowcap);
    
    % only saves Yr
    try
        wDat = savedata_per_cha(fname, 2, wDat, [0 1], ...
        cspf_3d.bkgate, cspf_3d.fshift, cspf_3d.blowcap);
    end
    
end

% save metadata
dataObj = matfile([fname, '_rawdata.mat'], 'Writable', true);

if ~isempty(strfind(wDat.bSide, 'R'))
    
    % Correct for side of the brain imaged
    eval(['wDat.mask = ', str2use, '(wDat.mask, 2);']);
    eval(['wDat.bMask = ', str2use, '(wDat.bMask, 2);']);
    eval(['wDat.RedChaMean = ', str2use, '(wDat.RedChaMean, 2);']);
    eval(['wDat.GreenChaMean = ', str2use, '(wDat.GreenChaMean, 2);']);
    
end

% perform 3D neighcorr
wDat.lc3D = neighcorr_3D(dataObj);

% compile field
wDat.cspf = 1; 
save([fname, '_metadata.mat'], 'wDat', '-append');

if ~strcmpi(pwd, cspf_3d.oDir)
    
    copyfile([fname, '_metadata.mat'], [cspf_3d.oDir, filesep, fname, '_metadata.mat']);
    copyfile([fname, '_rawdata.mat'], [cspf_3d.oDir, filesep, fname, '_rawdata.mat']);
    
    try
        copyfile([fname, '_refdata.mat'], [cspf_3d.oDir, filesep, fname, '_refdata.mat']);
    end
    
end

end

function wDat = savedata_per_cha(fname, cha2use, wDat, ...
    format2save, bkgate_, fshift_, blowcap_)
% savedata_per_cha: compile variable Data and transform it to Y and Yr for
% each channel selected, it also generates new wDat fields: GreenTrend, RedTrend
%
% Usage:
%   savedata_per_cha(fname, cha2use, wDat, format2save)
%
% Args:
%   fname: file to load
%   cha2use: channel to use (1 = *_rawdata or 2 = *_refdata)
%   wDat: metadata structure
%   format2save: flag to save Y and/or Yr
%   bkgate: flag for background substraction
%   	(default, 0)
%   fshift: shift distribution of F to the positive side
%   	(default, 6)
%   blowcap: fluorescence below which it is zerored
%   	(default, 0)

tinit = tic;
if exist('flip', 'builtin')
    str2use = 'flip';
else
    str2use = 'flipdim';
end

% Load files
load([fname, '_metadata.mat'], 'iDat');

if cha2use == 1
    
    % green channel
    load([fname, '_rawdata.mat'], 'Data');
    delete([fname, '_rawdata.mat'])
    dataObj = matfile([fname, '_rawdata.mat'], 'Writable', true);
    
else
    
    % red channel
    load([fname, '_refdata.mat'], 'Data');
    delete([fname, '_refdata.mat'])
    dataObj = matfile([fname, '_refdata.mat'], 'Writable', true);
    
end

% Correct for inverse z order
if strcmp(wDat.vOrient, 'invert')
    eval(['Data = ', str2use, '(Data, 3);']);
end

% background substract F
if bkgate_
    if cha2use == 1
        Data = Data - iDat.bs(end); 
    else
        Data = Data - iDat.bs(1);
    end
end

Data = Data + fshift_;
Data(Data < blowcap_) = blowcap_;

% remove whole nan-planes
Data = Data(:, :, wDat.plane2keep, :);

% Prune Data
Data = pruneIm(Data, wDat.mask);

% Correct for side of the brain imaged
% saving Data
if ~isempty(strfind(wDat.bSide, 'R'))
    
    eval(['Data = ', str2use, '(Data, 2);']);
    
    if cha2use == 1
        eval(['wDat.GreenTrend(1, :) = ', ...
            'stacktrend(Data, ', str2use, '(wDat.bMask, 2));'])
    else
        eval(['wDat.RedTrend(1, :) = ', ...
            'stacktrend(Data, ', str2use, '(wDat.bMask, 2));'])
    end
    
else
    
    if cha2use == 1
        wDat.GreenTrend(1, :) = stacktrend(Data, wDat.bMask);
    else
        wDat.RedTrend(1, :) = stacktrend(Data, wDat.bMask);
    end
    
end

% saving data using relative indexes
if format2save(1)
    dataObj.Y(1:wDat.fSize(1), 1:wDat.fSize(2), ...
        1:wDat.vSize(3), 1:wDat.Tn) = Data;
end

% indexes are sequential from plane to plane
if format2save(2)
    pixelindex = 1:prod(wDat.vSize);
    dataObj.Yr(pixelindex, 1:wDat.Tn) = ...
        reshape(Data, [prod(wDat.vSize), wDat.Tn]);
end

dataObj.nY = min(Data(:));
dataObj.sizY = [wDat.vSize, wDat.Tn];
clear iDat Data

fprintf([num2str(toc(tinit)), ' seconds\n'])

end

function fmed = stacktrend(Y, mask)
% stacktrend: get median trend per stack Y for just neural tissue (using mask)
%
% Usage:
%   stacktrend(Y, mask)
%
% Args:
%   Y: 3D stack
%   mask: mask that defines pixels to use

dDim = size(Y);
mask = mask(:);
Y = reshape(Y, [prod(dDim(1:3)), dDim(4)]);
Y = Y(mask ~= 0, :);
fmed = median(Y, 1);

end
