function batch_formatstacks(FolderName, FileName, iparams)
% batch_formatstacks: Second part of preprocessing for data
% that does not undergo compiling.
%   1) reads metadata generated by batch_SpaTemp_ResFilt 
%   2) saves variables in a ROIseg-compatible way
%       So Data is represented as Y, and flattened Data as Yr
%
% Usage:
%   batch_formatstacks(FolderName, FileName, iparams)
%
% Args:
%   FolderName: name of folders to load
%   FileName: name of files to load
%   iparams: parameters to update
%       (cDir: current directory)
%       (fo2reject: folders to reject)
%       (fi2reject: files to reject)
%       (fisuffix: suffix of files to load)
%       (oDir: temporary folder to copy data to)
%           (it copies *_metadata.mat, *_refdata.mat, and *_rawdata.mat)
%           (default, [])
%       (idp_run_flag: flag to run each selected file independently)
%           (default, 0)
%       (green_field2save: flag to save Data variable as [Y Yr], Yr is Y in 2D)
%           (default, [1 1])
%       (red_field2save: flag to save Data variable as [Y Yr], Yr is Y in 2D)
%           (default, [0 1])
%       (patch_z_size: dimension of patches to split whole matrix into)
%           (default, [10])
%       (patch_overlap: overlap across patches)
%           (default, [0 0 0])
%       (neighcor_flag: compute correlation of neighboring pixels acrosstime)
%           (default, 0)
%       %%%%%%%%%%%% shift fluorescence distribution %%%%%%%%%%%%
%       (bkgate: flag for background substraction)
%           (default, 0)
%       (blowcap: fluorescence below which it is zerored)
%           (default, 0)
%       (fshift: shift distribution of F to the positive side)
%           (default, 6)
%       %%%%%%%%%%%% parpool & server related %%%%%%%%%%%%
%       (serId: server id)
%           (default, 'int')
%       (corenum: number of cores)
%           (default, 4)
%
% Notes:

% default params
cspf = [];
cspf.cDir = pwd;
cspf.fo2reject = {'.', '..', 'preprocessed', ...
    'BData', 'rawtiff', 'motcor', 'stitch', ...
    'dfrel_vid', 'smod', 'roicov'};
cspf.fi2reject = {'Zstack'};
cspf.fisuffix = '_rawdata';
cspf.oDir = [];
cspf.idp_run_flag = 0;
cspf.green_field2save = [1 1];
cspf.red_field2save = [0 1];
cspf.patch_z_size = 10;
cspf.patch_overlap = [0 0 0];
cspf.neighcor_flag = 0;
cspf.bkgate = 0;
cspf.blowcap = 0;
cspf.fshift = [6 6];
cspf.serId = 'int';
cspf.corenum = 4;

% update variables
if ~exist('FolderName', 'var'); FolderName = []; end
if ~exist('FileName', 'var'); FileName = []; end
if ~exist('iparams', 'var'); iparams = []; end
cspf = loparam_updater(cspf, iparams);

% start pararell pool if not ready yet
ppobj = setup_parpool(cspf.serId, cspf.corenum);

if ~isempty(cspf.oDir)
    
    if ~exist(cspf.oDir, 'dir')
        mkdir(cspf.oDir);
    end    

else
    
    cspf.oDir = [];
    
end
fprintf(['Saving output files at : ', ...
	strrep(cspf.oDir, filesep, ' '), '\n'])

% Selecting folders
f2run = dir;
f2run = str2match(FolderName, f2run);
f2run = str2rm(cspf.fo2reject, f2run);
f2run = {f2run.name};
fprintf(['Running n-folders : ', num2str(numel(f2run)), '\n'])

for i = 1:numel(f2run)
    
    fprintf(['Running folder : ', f2run{i}, '\n']); 
    cd(f2run{i});
    runperfolder(FileName, cspf);
    cd(cspf.cDir);
    fprintf('\n')
    
end

delete_parpool(ppobj);

fprintf('... Done\n')

end

function runperfolder(fname, cspf)
% runperfolder: run all files per folder
%
% Usage:
%   runperfolder(fname)
%
% Args:
%   fname: file name pattern
%   cspf: internal parameters structure

% determine if fname narrows down to just one file
[f2plot, ~, rep2plot] = rdir_namesplit(...
    fname, '.mat', cspf.fisuffix, ...
    cspf.fi2reject, [], 1);
fprintf('Reformatting stacks from');

if cspf.idp_run_flag == 1
    
    for i = 1:numel(f2plot)
        % run single file
        f2plot{i} = [f2plot{i}, '_', num2str(rep2plot(i))];
    end
    fprintf(' each seg independently ') 
    
else
    
    if numel(f2plot) == 1 && numel(rep2plot) == 1
        % run single file
        f2plot{1} = [f2plot{1}, '_', num2str(rep2plot)];
        fprintf(' one fly_seg ')
    else
        % Run all flies per folder
        f2plot = unique(f2plot);
    end
    
end

fprintf([num2str(numel(f2plot)), ' flies\n'])

for file_i = 1:numel(f2plot)
    
    % Compiling all stacks per fly
    [filename, ~, repnum] = ...
        rdir_namesplit(f2plot{file_i}, ...
        '.mat', cspf.fisuffix, cspf.fi2reject, [], 1);
    
    % run per fly
    for rep_i = 1:numel(repnum)
        
        if numel(filename) == 1
            
            fprintf(['Reformatting fly: ', ...
                filename{1}, '_', num2str(repnum(rep_i)),'\n'])
            fcompiler([filename{1}, '_', num2str(repnum(rep_i))], cspf);
            
        else
            fprintf('error')
        end
        
    end
    
end

end

function fcompiler(fname, cspf)
% fcompiler: for each filename compile all sub-stacks in the right order
%
% Usage:
%   fcompiler(fname)
%
% Args:
%   fname: file name
%   cspf: internal parameters structure

% load previously generated wDat
load([fname, '_metadata.mat'], 'wDat');
wDat.cDir = pwd;

if ~isfield(wDat, 'vSize')
    fprintf('No imaging data found\n')
    return
end

% add local folder
if isfield(wDat, 'min_f')
    wDat = rmfield(wDat, 'min_f');
end

% rerun already used metadata
if isfield(wDat, 'cspf')
    
    % it has already being used to compile Data
    fprintf('Reseting metadata to be reused\n')
    
    if ~isempty(strfind(wDat.bSide, 'R'))
        
        % reset original order in frame width
        wDat.mask = flip(wDat.mask, 2);
        wDat.bMask = flip(wDat.bMask, 2);
        wDat.RedChaMean = flip(wDat.RedChaMean, 2);
        wDat.GreenChaMean = flip(wDat.GreenChaMean, 2);
        
    end
    
end

% correct each channel separately
vList = whos('-file', [fname, '_rawdata']);

if ~contains([vList.name], 'Y')
    
    % saves Y and Yr
    wDat_red = wDat;
    wDat = savedata_per_cha(fname, 'green', wDat, ...
        cspf.green_field2save, ...
        cspf.bkgate, cspf.fshift(2), ...
        cspf.blowcap, cspf.patch_z_size, ...
        cspf.patch_overlap);
    
    % saves Y and Yr
    try
        wDat_red = savedata_per_cha(fname, 'red', wDat_red, ...
            cspf.red_field2save, ...
            cspf.bkgate, cspf.fshift(1), ...
            cspf.blowcap, cspf.patch_z_size, ...
            cspf.patch_overlap);
       wDat.RedTrend = wDat_red.RedTrend;
    end
    
end

% prune bmask
if ~isempty(wDat.bMask)
    wDat.bMask = pruneIm(wDat.bMask, wDat.mask);
end

if wDat.vSize(3) > 1
    if ~isempty(wDat.bMask)
        wDat.bMask = wDat.bMask(:, :, wDat.plane2keep);
    end
end

% Correct for side of the brain imaged
if ~isempty(strfind(wDat.bSide, 'R'))
    
    wDat.mask = flip(wDat.mask, 2);
    wDat.bMask = flip(wDat.bMask, 2);
    wDat.RedChaMean = flip(wDat.RedChaMean, 2);
    wDat.GreenChaMean = flip(wDat.GreenChaMean, 2);
    
end

% save metadata
dataObj = matfile([fname, '_rawdata.mat'], 'Writable', true);

% perform 3D neighcorr
if cspf.neighcor_flag
    wDat.lc3D = neighcorr_3D(dataObj);
end

% compile field
wDat.cspf = 1; 
save([fname, '_metadata.mat'], 'wDat', '-append');

if ~isempty(cspf.oDir)
    
    tinit_i = tic;
    copyfile([fname, '_metadata.mat'], ...
        [cspf.oDir, filesep, fname, '_metadata.mat']);
    fprintf([num2str(toc(tinit_i)), ' seconds\n'])

    tinit_i = tic;
    copyfile([fname, '_rawdata.mat'], ...
        [cspf.oDir, filesep, fname, '_rawdata.mat']);
    fprintf([num2str(toc(tinit_i)), ' seconds\n'])
    
    try
        tinit_i = tic;
        copyfile([fname, '_refdata.mat'], ...
            [cspf.oDir, filesep, fname, '_refdata.mat']);
        fprintf([num2str(toc(tinit_i)), ' seconds\n'])
    end
    
end

end

function wDat = savedata_per_cha(fname, ...
    cha2use, wDat, format2save, bkgate_, ...
    fshift_, blowcap_, patch_z_size, ...
    patch_overlap)
% savedata_per_cha: compile variable Data and transform it to Y and Yr for
% each channel selected, it also generates new wDat fields: GreenTrend, RedTrend
%
% Usage:
%   savedata_per_chasavedata_per_cha(fname, ...
%       cha2use, wDat, format2save, bkgate_, ...
%       fshift_, blowcap_, patch_z_size, ...
%       patch_overlap)
%
% Args:
%   fname: file to load
%   cha2use: channel to use (green = *_rawdata or red = *_refdata)
%   wDat: metadata structure
%   format2save: flag to save Y and/or Yr
%   bkgate: flag for background substraction
%   	(default, 0)
%   fshift: shift distribution of F to the positive side
%   	(default, 6)
%   blowcap: fluorescence below which it is zerored
%   	(default, 0)
%   patch_z_size: dimension of patches to split whole matrix into
%       (default, [10])
%   patch_overlap: overlap across patches
%       (default, [0 0 0])

% generate patches
if wDat.vSize(3) > 1
    
    if wDat.vSize(3) > 2
        patches_ = construct_patches(wDat.vSize, ...
            [wDat.vSize([1 2]), patch_z_size], ...
            patch_overlap);
    else
        patches_{1} = [1, wDat.vSize(1), ...
            1, wDat.vSize(2), 1, 2];
    end
    
else
    
    patches_{1} = [1, wDat.vSize(1), 1, ...
        wDat.vSize(2), 1, 1];   
    
end

% tag planes to remove (whole nan-planes (3D data only))
if wDat.vSize(3) > 1
    
    try
        siz = size(wDat.GreenChaMean);
        nan_pix = isnan(wDat.GreenChaMean);
    catch
        siz = size(wDat.RedChaMean);
        nan_pix = isnan(wDat.RedChaMean);        
    end
    
    wDat.plane2keep = sum(reshape(nan_pix, ...
        [prod(siz([1 2])) siz(3)])) ~= prod(siz([1 2]));

    % prune average images
    if ~isempty(wDat.RedChaMean)
        wDat.RedChaMean = ...
            wDat.RedChaMean(:, :, wDat.plane2keep);
    end
    
    if ~isempty(wDat.GreenChaMean)
        wDat.GreenChaMean = ...
            wDat.GreenChaMean(:, :, wDat.plane2keep);
    end
    
end

% prune XY nan pixels
if ~isempty(wDat.RedChaMean)
    wDat.RedChaMean = pruneIm(wDat.RedChaMean, wDat.mask);
end

if ~isempty(wDat.GreenChaMean)
    wDat.GreenChaMean = pruneIm(wDat.GreenChaMean, wDat.mask);
end

% update size
if ~isempty(wDat.RedChaMean)
    wDat.fSize = [size(wDat.RedChaMean, 1), size(wDat.RedChaMean, 2)];
else
    wDat.fSize = [size(wDat.GreenChaMean, 1), size(wDat.GreenChaMean, 2)];
end

if wDat.vSize(3) > 1
    
    if ~isempty(wDat.RedChaMean)
        wDat.vSize = [wDat.fSize, size(wDat.RedChaMean, 3)];
    else
        wDat.vSize = [wDat.fSize, size(wDat.GreenChaMean, 3)];
    end    
    
else
    
    wDat.vSize = [wDat.fSize, 1];
    
end

tinit = tic;

% load files
if contains(cha2use, 'green')
    
    % green channel
    dataObj_in = matfile([fname, '_rawdata.mat'], 'Writable', true);
    dataObj_out = matfile([fname, '_rawdata_temp.mat'], 'Writable', true);
    
elseif contains(cha2use, 'red')
    
    % red channel
    dataObj_in = matfile([fname, '_refdata.mat'], 'Writable', true);
    dataObj_out = matfile([fname, '_refdata_temp.mat'], 'Writable', true);
    
end

% Compile stacks
z_i = 0;
p_i = 0;
minval = zeros(numel(patches_), 1);

if wDat.vSize(3) > 1
    if strcmp(wDat.vOrient, 'invert')
        patches_i = sort(1:numel(patches_), 'descend');
    else
        patches_i = sort(1:numel(patches_), 'ascend');
    end
end

for i = 1:numel(patches_)
    
    % load, reshape, prune, flip on Z and X axis patches of data
    tinit_i = tic;
    if contains(cha2use, 'green')
        [Y, wDat.GreenTrend(i, :), minval(i, 1)] = ...
            load_reshape_data_patch(dataObj_in, ...
            patches_{patches_i(i)}, wDat, bkgate_, ...
            fshift_, blowcap_, cha2use);
    elseif contains(cha2use, 'red')
        [Y, wDat.RedTrend(i, :), minval(i, 1)] = ...
            load_reshape_data_patch(dataObj_in, ...
            patches_{patches_i(i)}, wDat, bkgate_, ...
            fshift_, blowcap_, cha2use);
    end
    
    if wDat.vSize(3) > 1
        
        % get relative depth
        planes = 1:size(Y, 3);
        planes = planes + z_i;
        z_i = planes(end);

        % saving data using relative indexes
        if format2save(1)
            dataObj_out.Y(1:wDat.fSize(1), 1:wDat.fSize(2), ...
                planes, 1:wDat.Tn) = Y;
        end
        Zn = size(Y, 3);
        
    else
        
        if format2save(1)
            dataObj_out.Y(1:wDat.fSize(1), 1:wDat.fSize(2), ...
                1:wDat.Tn) = Y;
        end
        
    end

    if wDat.vSize(3) > 1
        
        % indexes are sequential from plane to plane
        pixelindex = 1:prod([wDat.fSize, Zn]);
        pixelindex = pixelindex + p_i;
        p_i = pixelindex(end);
        if format2save(2)
            dataObj_out.Yr(pixelindex, 1:wDat.Tn) = ...
                reshape(Y, [prod([wDat.fSize, Zn]), wDat.Tn]);
        end
        
    else
        
        pixelindex = 1:prod(wDat.vSize);
        if format2save(2)
            dataObj_out.Yr(pixelindex, 1:wDat.Tn) = ...
                reshape(Y, [prod(wDat.vSize), wDat.Tn]);
        end
    
    end
    
    fprintf([num2str(toc(tinit_i)), ' seconds\n'])
    
end
fprintf('\n')

dataObj_out.nY = min(minval);
if wDat.vSize(3) > 1
    dataObj_out.sizY = [wDat.vSize, wDat.Tn];
else
    dataObj_out.sizY = [wDat.vSize(1:2), wDat.Tn];
end
clear Y

% delete original:
if contains(cha2use, 'green')
    delete([fname, '_rawdata.mat'])
    movefile([fname, '_rawdata_temp.mat'], ...
        [fname, '_rawdata.mat']);
elseif contains(cha2use, 'red')
    delete([fname, '_refdata.mat'])
    movefile([fname, '_refdata_temp.mat'], ...
        [fname, '_refdata.mat']);
end

fprintf([num2str(toc(tinit)), ' seconds\n'])

end

function [Y, trend_over_time, minval] = ...
    load_reshape_data_patch(dataObj, ...
    patches_, wDat, bkgate_, fshift_, ...
    blowcap_, cha2use)
% load_reshape_data_patch: compile patches of 
%   'dataObj.Data' matrix using 'patches_'
%   it formats Y (flip in X and Z axis), and prune nan pixels, and
%   generates trend_over_time (mean trend over time)
%
% Usage:
%   [Y, trend_over_time, minval] = ...
%       load_reshape_data_patch(dataObj, ...
%       patches_, wDat, bkgate_, fshift_, ...
%       blowcap_, cha2use)
%
% Args:
%   dataObj: mat file object (looks for variable Data)
%   patches_: edges of 'dataObj.Data' to use
%   wDat: metadata structure
%   bkgate: flag for background substraction
%   	(default, 0)
%   fshift: shift distribution of F to the positive side
%   	(default, 6)
%   blowcap: fluorescence below which it is zerored
%   	(default, 0)
%   cha2use: channel to use (green = *_rawdata or red = *_refdata)

z_idx = patches_(5):patches_(6);

% load patch
if wDat.vSize(3) > 1
    Y = dataObj.Data(patches_(1):patches_(2), ...
        patches_(3):patches_(4), ...
        z_idx, :);
else
    Y = dataObj.Data(patches_(1):patches_(2), ...
        patches_(3):patches_(4), :);   
end

% load brain mask (whole image)
brainmask = wDat.bMask(patches_(1):patches_(2), ...
    patches_(3):patches_(4), :);

% Correct for inverse z order
%  wDat.plane2keep & brainmask (wDat.bMask)
if wDat.vSize(3) > 1
    if strcmp(wDat.vOrient, 'invert')
        plane2keep = flip(wDat.plane2keep);
        brainmask = flip(brainmask, 3);
    else
        plane2keep = wDat.plane2keep;
    end
    brainmask = brainmask(:, :, z_idx);
end

% remove whole nan-planes
if wDat.vSize(3) > 1
    Y = Y(:, :, plane2keep(z_idx), :);
    brainmask = brainmask(:, :, plane2keep(z_idx));
end

% get trend per patch
trend_over_time = [];
trend_over_time(1, :) = stacktrend(Y, brainmask);

% Correct for inverse z order (Y)
if wDat.vSize(3) > 1
    if strcmp(wDat.vOrient, 'invert')
        Y = flip(Y, 3);
    end
end

% Prune Data
%   (wDat.mask generated by batch_SpaTemp_ResFilt)
Y = pruneIm(Y, wDat.mask);

% correct for side of the brain imaged
%   (wDat.bMask generated by batch_brainmaskgen)
if ~isempty(strfind(wDat.bSide, 'R'))
    Y = flip(Y, 2);
end

% background substract F
if bkgate_
    if cha2use == 1
        Y = Y - wDat.bs(end); 
    else
        Y = Y - wDat.bs(1);
    end
end

Y = Y + fshift_;
Y(Y < blowcap_) = blowcap_;

minval = min(Y(:));

end

function fmed = stacktrend(Y, mask)
% stacktrend: get median trend per stack Y 
%   for just neural tissue (using mask)
%
% Usage:
%   stacktrend(Y, mask)
%
% Args:
%   Y: 3D or 2D stack
%   mask: mask that defines pixels to use

dDim = size(Y);
mask = mask(:);
if length(dDim) == 4
    Y = reshape(Y, [prod(dDim(1:3)), dDim(4)]);
else
    Y = reshape(Y, [prod(dDim(1:2)), dDim(3)]); 
end
Y = Y(mask ~= 0, :);
fmed = median(Y, 1);

end
